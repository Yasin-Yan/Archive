### Java面试整理

#### 一、SQL

##### 1、索引结构

- 索引：索引是高效检索数据的一种数据结构，MySQL中索引是由B+树实现的

- B+树：多路查找平衡树，可以有多个子节点，只有叶子结点才存储数据，叶子结点之间通过指针连接。
- 主键索引：key为主键id，叶子结点存储的数据为该行的全部数据
- 非聚集索引(二级索引/辅助索引)：key为创建索引的字段的值，叶子结点存储的值为该行的id
- 回表查询：当查询返回字段在查询条件中不存在，并且不是根据id查询的时候，先回查二级索引找到id，再根据主键id去主键索引查找其他返回字段。

> 非聚集索引和聚集索引区别：索引和数据是否存在一起

##### 2、索引创建原则

+ 尽量在区分度高的列上创建索引，重复数据少
+ 如果要创建索引的列内容比较长，可以使用前缀索引
+ 尽量创建联合索引而不是单个索引
+ 在经常需要查询、排序、非组的字段上创建索引
+ 

##### 3、索引失效情况

+ 查询条件用`or`连接的两个字段，如果前面的一个创建了索引后面的一个没有，索引会失效
+ 查询时针对联合索引没有遵循最左匹配原则，索引会失效
+ 对字符串类型查询时没有加引号会发生隐式类型转换，索引失效
+ 优化器优化时认为使用索引还没有直接全表查询来得快会不走索引进行查询

##### 4、慢查询

1. 查看MySQL的慢查询日志，定位是哪一条SQL语句
2. 使用`explain`查询计划对sql进行分析，没有索引创建索引，索引失效则根据相应的情形去解决

##### 5、隔离级别

> 读未提交、读已提交、可重复读、串行化
>
> 为了方便理解，放一起总结

+ 读未提交

  事务A读取事务B修改但还未提交的数据，两次不一致，导致`脏读`

  为了解决脏读，事务A只能读取事务B已经提交的内容

+ 读已提交

  事务A读取数据库记录，事务B对这条数据进行修改并提交，事务A再次读取，两次数据不一致，导致`不可重复读`

  导致不可重复读的原因是因为采取的是`当前读`，只读取数据库中的最新信息，为了解决`不可重复读`，可以采取`快照读`的方法

+ 可重复读

  采用`快照读`的方式，在事务第一次查询时会创建一个快照，后序查询直接从快照中拿取。由于使用`快照读`，事务A查询某条数据时不存在，事务B插入这条数据，事务A此时插入会发现这条数据已经存在了，但是却查不出来，导致`幻读`

+ 串行化

  最高隔离级别

> MySQL默认隔离级别时可重复读，Oracle默认隔离级别是读已提交

##### 6、MVCC

为了解决幻读问题MySQL提出来的一种方案，保留每一次操作的数据，像链表一样串联起来，根据相应的情况确定取哪一个版本的数据

个人理解：用一套算法确定取`当前读`还是`快照读`



#### 二、Spring Boot & Spring MVC

##### 1、事务失效的原因

+ 最常见的是在`try-catch`里手动处理了异常并没有接着向上抛出，事务切面无法感知，事务失效

+ 事务默认只对运行时异常生效，如果代码中抛出的是检查异常则不会生效

  > 解决方法：设置rollbackFor属性为Exception.class

+ 事务切面使用的代理方法要求是public的，所以方法必须是public修饰的

+ 由于事务是一个切面，如果我们对方法设置了切面，当自定义切面中抛出异常时，自定义切面属于外层切面，事务切面也不会感知到

##### 2、循环依赖的解决办法

- @Lazy
- 待学习

##### 3、SpringBoot自动装配原理

+ 待学习



#### 三、微服务

##### 1、服务注册与发现

> 首先，服务的消费者需要知道提供者的地址和端口号，Nacos服务注册与发现，可以将提供者的地址和端口号注册到注册中心，然后消费者可以从服务集群中选择一个实例进行消费。

##### 2、负载均衡

> 每一个实例的承受的访问压力比较平均。以前**Ribbon**,现在**loadbalancer**

+ 常用负载均衡算法
  - 随即
  - 轮询
  - 加权轮询

##### 3、服务网关

> 微服务太多，前端需要一个统一的入口，gate-way组件会对前端的路由进行路由判断，然后通过负载均衡选择一个集群中的实例进行转发

+ 权限验证

  可以在网关加上全局过滤器或者自定义拦截器，对前端的请求进行权限验证后放行

+ 网关用户信息传递

  可以验证用户权限后将用户信息存在当前请求的请求头中，传递到下游服务，下游服务设置拦截器从请求头中取出用户信息放在一个由ThreadLocal实现的用户上下文中，后续使用时直接拿取即可

##### 4、远程调用

> 服务与服务中间相互调用需要发送Http请求，一般可以使用RestTemplate，单要固定地址和端口号。使用OpenFeign可以实现服务之间的远程调用

##### 5、服务保护

> 并发量很大的情况下导致某个服务挂掉，后序依赖于此服务的服务会发生连锁反应，全部挂掉，是为服务雪崩。可以使用**sentinel**组件来实现请求限流和线程隔离

- 请求限流

  限制每个微服务的QPS，超出的请求会被拒绝

- 线程隔离

  限制每个微服务可用的线程数，例如线程数为5，平均响应500ms，则QPS为10

- 服务降级

  使用请求限流和线程隔离技术后，如果拒绝的请求数太多，说明该服务出现故障，立即熔断该服务。开始使用降级策略，如查询服务直接返回一个空列表。

##### 6、分布式事务

> 分布式系统中会发生服务间的相互调用，假设有这样一个功能下单操作会调用用户服务进行扣款然后调用购物车服务清空购物车。若清空购物操作出现异常，则下单扣减库存，用户扣款事务也要发生会滚。使用**seata**组件实现分布式事务

+ XA模式

  各分支事务处理完毕后不提交，先报告给事务协调器，事务协调器监测到全部分支事务执行成功后再发出指令统一提交。

+ AT模式

  各分支事务处理完毕后直接提交，并记录提交前后的日志，事务协调器监测到某个分支事务异常，则会给其他分支事务发送指令根据日志进行会滚。

##### 7、分布式理论

+ CAP

  Consistency：一致性

  Avability：可用性

  Partion Tolerance：分区容错性

  > 由于微服务直接使用网络连接的原因，由于网络原因导致服务之间的隔离是必然存在的。要保证一致性，就需要同步两个分区之间的数据，在等待网络恢复和数据同步的时候，服务的可用性无法得到保证。
  >
  > 反之，要保证可用性，分区之间就会存在数据不一致的问题。所以分布式系统只有两种架构，保证强数据一致性的CP架构和保证最终一致性的AP架构。

+ BASE

  待复习









